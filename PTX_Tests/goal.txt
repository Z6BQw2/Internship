Step 1. Find how the registers used by mma_sync are chosen by trying different registers through [asm volatile("mov.f32 ...] in order to put register values in actual printable variables.

First Step failed, onto step 2

Step 2. 2 options are available. The limitation of Step 1 is that PTX forces the use of virtual registers. I can either go down to SASS to check actual registers by name, or stay with PTX and create my own mma_sync to control the register access.
Option 1 seems the most difficult, but also the most amusing, so I'll start exploring it.

My choice is done, I'll use cubin and cuobjdump -sass to get the sass of my matmul, and find how registers are stored by hand.

After looking for information as to how to execute .sass, it's now clear that it's not possible as is. Option 2 therefore seems like the only option.

After digging deeper and performing some tests, it seems the most effective method would be to implement my own driver Ã  la asfermi to control the data-flow in-register better. That is a tremendous task, though, but it sure does seem fun. I'll go with the straight forward asm volatile approach, exploiting mma_sync in a PTX-wise fashion (aka using the PTX instruction instead of the cuda one) to impose the data-flow, and have more insight on the registers used. If this proves effective, and I achieve quantifiable results, I'll spend the rest of the internship trying the driver approach.
